<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Color Place</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css">
<style>
:root {
  --cell: min(64px, calc((100vw - 60px) / 5.8));
  --tile: calc(var(--cell) * 0.75);
  --gap: 4px;
  --board-pad: 8px;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { overflow-x: hidden; }
body {
  font-family: 'Pretendard', -apple-system, 'Segoe UI', sans-serif;
  background: #1a1a2e;
  color: #eee;
  display: flex;
  justify-content: center;
  min-height: 100dvh;
  user-select: none;
  -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}
#app {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  padding: 16px 8px;
  width: 100%;
  max-width: 420px;
}
h1 { font-size: 22px; color: #fff; letter-spacing: 2px; }

/* Top bar */
#top-bar {
  display: flex;
  gap: 20px;
  align-items: center;
  font-size: 15px;
  color: #aaa;
  width: 100%;
  justify-content: center;
}
#top-bar .val { color: #fff; font-weight: bold; font-size: 20px; margin-left: 10px; }
#combo-display { color: #e94560; transition: opacity 0.3s; }
#combo-display.hidden { opacity: 0; }
#level-display { color: #FBBC04; font-size: 12px; }

/* Queue */
#queue-area {
  display: flex;
  gap: 10px;
  align-items: center;
}
.queue-slot {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  padding: 6px 12px;
  background: #16213e;
  border-radius: 10px;
  border: 2px solid #0f3460;
  min-width: 68px;
}
.queue-slot.current { border-color: #e94560; }
.queue-slot .label { font-size: 9px; color: #555; text-transform: uppercase; letter-spacing: 1px; }
.queue-slot .tile-preview {
  width: 36px; height: 36px; border-radius: 50%;
  overflow: hidden;
  transition: background 0.3s;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}
.queue-slot .tile-preview .tile-num {
  position: relative;
  z-index: 2;
  font-size: 14px;
  font-weight: bold;
  text-shadow: none;
  line-height: 1;
}
.queue-slot .tile-preview .tile-line {
  position: absolute;
  background: rgba(255,255,255,0.9);
  z-index: 1;
}
.queue-slot .tile-preview .tile-line.horizontal {
  width: 100%; height: 40%;
  top: 50%; left: 0;
  transform: translateY(-50%);
}
.queue-slot .tile-preview .tile-line.vertical {
  width: 40%; height: 100%;
  left: 50%; top: 0;
  transform: translateX(-50%);
}
/* Cross: both lines */
.queue-slot .tile-preview .tile-line.cross-h {
  width: 100%; height: 30%;
  top: 50%; left: 0;
  transform: translateY(-50%);
}
.queue-slot .tile-preview .tile-line.cross-v {
  width: 30%; height: 100%;
  left: 50%; top: 0;
  transform: translateX(-50%);
}

/* Colorless tile preview */
.color-unknown {
  background: #666 !important;
}

/* Mission */
#mission-area {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 14px;
  background: #16213e;
  border-radius: 8px;
  border: 1px solid #0f3460;
  min-height: 80px;
  height: 80px;
}
#mission-label { font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 1px; }
#mission-grid {
  display: inline-grid;
  gap: 2px;
}
.mission-dot {
  width: 12px; height: 12px; border-radius: 50%;
  background: #888;
}
.mission-dot.empty {
  background: transparent;
}
#mission-bonus { color: #FBBC04; font-size: 12px; font-weight: bold; }

/* Status */
#status-area {
  min-height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}
#status {
  font-size: 13px;
  color: #e94560;
  text-align: center;
  padding: 3px 14px;
  background: rgba(233,69,96,0.15);
  border-radius: 6px;
  transition: opacity 0.2s;
}
#status.hidden { opacity: 0; pointer-events: none; }

/* Board */
#board-section {
  display: flex;
  flex-direction: column;
  align-items: center;
}
#col-labels {
  display: grid;
  grid-template-columns: repeat(5, var(--cell));
  gap: var(--gap);
  padding-left: 22px;
  padding-bottom: 3px;
}
#col-labels .lbl { text-align: center; font-size: 11px; color: #444; }
#board-wrapper { display: flex; }
#row-labels {
  display: flex;
  flex-direction: column;
  gap: var(--gap);
  padding-right: 4px;
}
#row-labels .lbl {
  height: var(--cell);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  color: #444;
  width: 18px;
}
#board {
  display: grid;
  grid-template-columns: repeat(5, var(--cell));
  grid-template-rows: repeat(5, var(--cell));
  gap: var(--gap);
  background: #16213e;
  padding: var(--board-pad);
  border-radius: 12px;
  border: 2px solid #0f3460;
}

/* Cells */
.cell {
  width: var(--cell);
  height: var(--cell);
  background: #0f3460;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background 0.15s, box-shadow 0.15s;
  position: relative;
}
.cell:active { transform: scale(0.95); }
.cell.highlight {
  background: #1a4a7a;
  box-shadow: inset 0 0 0 2px rgba(255,255,255,0.2);
}
.cell.change-target {
  box-shadow: inset 0 0 0 2px rgba(255,255,255,0.35);
}

/* Tiles */
.cell .tile {
  width: var(--tile);
  height: var(--tile);
  border-radius: 50%;
}
.cell .tile.pop { animation: popAnim 0.4s ease-out forwards; }
.cell .tile.place { animation: placeAnim 0.25s ease-out; }
.cell .tile.color-swap { animation: swapAnim 0.5s ease-out; }

/* Void tile */
.cell .tile.void-tile {
  border-radius: 50%;
  position: relative;
  overflow: hidden;
}
.cell .tile.void-tile::after {
  content: '';
  position: absolute;
  top: 0; right: 0;
  width: 50%; height: 100%;
  background: #555;
  border-radius: 0 999px 999px 0;
}

@keyframes popAnim {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.3); opacity: 0.5; }
  100% { transform: scale(0); opacity: 0; }
}
@keyframes placeAnim {
  0% { transform: scale(0); }
  60% { transform: scale(1.15); }
  100% { transform: scale(1); }
}
@keyframes swapAnim {
  0% { transform: scale(1); filter: brightness(2); }
  50% { transform: scale(1.2); filter: brightness(2); }
  100% { transform: scale(1); filter: brightness(1); }
}

/* Colors - set dynamically by theme */
.color-red { background: var(--c-red); }
.color-orange { background: var(--c-orange); }
.color-yellow { background: var(--c-yellow); }
.color-green { background: var(--c-green); }
.color-blue { background: var(--c-blue); }
.color-indigo { background: var(--c-indigo); }
.color-violet { background: var(--c-violet); }

/* Theme selector */
#theme-btn {
  position: absolute;
  top: 16px;
  right: 12px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  color: #ccc;
  font-size: 18px;
  width: 36px; height: 36px;
  border-radius: 50%;
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  z-index: 30;
}
#theme-btn:active { background: rgba(255,255,255,0.2); }
#theme-panel {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.7);
  z-index: 100;
  justify-content: center;
  align-items: center;
}
#theme-panel.active { display: flex; }
#theme-list {
  background: #2a2a3e;
  border-radius: 16px;
  padding: 20px;
  width: 90%;
  max-width: 360px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}
#theme-list h3 {
  text-align: center;
  font-size: 16px;
  color: #fff;
  margin-bottom: 4px;
}
.theme-option {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 10px;
  cursor: pointer;
  border: 2px solid transparent;
  background: rgba(255,255,255,0.05);
  transition: border-color 0.2s;
}
.theme-option.selected { border-color: #fff; }
.theme-option:active { background: rgba(255,255,255,0.1); }
.theme-name {
  font-size: 14px;
  color: #ddd;
  flex: 1;
}
.theme-dots {
  display: flex;
  gap: 4px;
}
.theme-dots span {
  width: 18px; height: 18px;
  border-radius: 50%;
  display: inline-block;
}

/* Game Over */
#game-over {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.88);
  z-index: 100;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 14px;
}
#game-over.active { display: flex; }
#game-over h2 { font-size: 32px; color: #e94560; }
#game-over p { font-size: 20px; }
#game-over .sub { font-size: 14px; color: #888; }
#game-over button {
  padding: 14px 36px;
  font-size: 18px;
  border: none;
  border-radius: 10px;
  background: #e94560;
  color: #fff;
  cursor: pointer;
  margin-top: 8px;
}
#game-over button:active { background: #c73650; }

/* Popups */
.combo-popup {
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%,-50%) scale(0);
  font-size: 44px;
  font-weight: bold;
  color: #e94560;
  text-shadow: 0 0 20px rgba(233,69,96,0.6);
  pointer-events: none;
  z-index: 50;
  animation: comboAnim 1.6s ease-out forwards;
}
@keyframes comboAnim {
  0% { transform: translate(-50%,-50%) scale(0); opacity:1; }
  20% { transform: translate(-50%,-50%) scale(1.2); opacity:1; }
  60% { transform: translate(-50%,-50%) scale(1); opacity:0.9; }
  100% { transform: translate(-50%,-50%) scale(0.8); opacity:0; }
}
.mission-popup {
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%,-50%) scale(0);
  font-size: 24px;
  font-weight: bold;
  color: #FBBC04;
  text-shadow: 0 0 15px rgba(251,188,4,0.5);
  pointer-events: none;
  z-index: 50;
  animation: missionAnim 1.8s ease-out forwards;
}
@keyframes missionAnim {
  0% { transform: translate(-50%,-50%) scale(0); opacity:1; }
  20% { transform: translate(-50%,-50%) scale(1.1); opacity:1; }
  60% { transform: translate(-50%,-50%) scale(1); opacity:0.9; }
  100% { transform: translate(-50%,-50%) scale(0.9); opacity:0; }
}
.level-popup {
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%,-50%) scale(0);
  font-size: 20px;
  font-weight: bold;
  color: #4285F4;
  text-shadow: 0 0 15px rgba(66,133,244,0.5);
  pointer-events: none;
  z-index: 50;
  animation: missionAnim 1.8s ease-out forwards;
}
</style>
</head>
<body>
<div id="app" style="position:relative;">
  <button id="theme-btn" onclick="toggleThemePanel()">üé®</button>
  <h1>Color Place</h1>
  <div id="top-bar">
    <div>SCORE <span class="val" id="score">0</span></div>
    <div id="combo-display" class="hidden">COMBO <span class="val" id="combo">0</span></div>
  </div>
  <div id="level-display"></div>

  <div id="queue-area">
    <div class="queue-slot current" id="q-current">
      <div class="label">Current</div>
      <div class="tile-preview" id="qp-current"></div>
    </div>
    <div class="queue-slot" id="q-next">
      <div class="label">Next</div>
      <div class="tile-preview" id="qp-next"></div>
    </div>
    <div class="queue-slot" id="q-nextnext">
      <div class="label">Next+</div>
      <div class="tile-preview" id="qp-nextnext"></div>
    </div>
  </div>

  <div id="mission-area">
    <span id="mission-label">MISSION</span>
    <div id="mission-grid"></div>
    <span id="mission-bonus"></span>
  </div>

  <div id="status-area">
    <div id="status" class="hidden">-</div>
  </div>

  <div id="board-section">
    <div id="col-labels"></div>
    <div id="board-wrapper">
      <div id="row-labels"></div>
      <div id="board"></div>
    </div>
  </div>
</div>

<div id="theme-panel" onclick="if(event.target===this)toggleThemePanel()">
  <div id="theme-list"></div>
</div>

<div id="game-over">
  <h2>GAME OVER</h2>
  <p>ÏµúÏ¢Ö Ï†êÏàò: <span id="final-score">0</span></p>
  <p class="sub" id="final-combo"></p>
  <p class="sub" id="final-level"></p>
  <button onclick="initGame()">Îã§Ïãú ÏãúÏûë</button>
</div>

<script>
// ============================================================
// CONSTANTS
// ============================================================
const ALL_COLORS = ['red','orange','yellow','green','blue','indigo','violet'];
const COLOR_KR = {red:'Îπ®',orange:'Ï£º',yellow:'ÎÖ∏',green:'Ï¥à',blue:'Ìåå',indigo:'ÎÇ®',violet:'Î≥¥'};
let COLOR_HEX = {red:'#FF6B6B',orange:'#FFA94D',yellow:'#FFE066',green:'#69DB7C',blue:'#74C0FC',indigo:'#B197FC',violet:'#F783AC'};

const THEMES = {
  pastel:  { name: 'ÌååÏä§ÌÖî', hex: {red:'#FF6B6B',orange:'#FFA94D',yellow:'#FFE066',green:'#69DB7C',blue:'#74C0FC',indigo:'#B197FC',violet:'#F783AC'} },
  jewel:   { name: 'Î≥¥ÏÑù',   hex: {red:'#E63946',orange:'#E9A820',yellow:'#F4845F',green:'#2EC4B6',blue:'#457B9D',indigo:'#7B2D8E',violet:'#547AA5'} },
  neon:    { name: 'ÎÑ§Ïò®',   hex: {red:'#FF006E',orange:'#FF5400',yellow:'#FFBE0B',green:'#06D6A0',blue:'#118AB2',indigo:'#8338EC',violet:'#FF85A1'} },
  earth:   { name: 'Ïñ¥Ïä§',   hex: {red:'#C97C7C',orange:'#C77B5A',yellow:'#D4A843',green:'#8DB580',blue:'#6B8CAE',indigo:'#A67DB8',violet:'#7CA982'} },
  candy:   { name: 'Ï∫îÎîî',   hex: {red:'#FF7EB3',orange:'#FF9671',yellow:'#FFC75F',green:'#9EDE73',blue:'#4ECDC4',indigo:'#7C83FD',violet:'#C490E4'} },
};
let currentTheme = localStorage.getItem('colorplace-theme') || 'pastel';

function applyTheme(themeId) {
  currentTheme = themeId;
  localStorage.setItem('colorplace-theme', themeId);
  const t = THEMES[themeId].hex;
  COLOR_HEX = {...t};
  const root = document.documentElement.style;
  ALL_COLORS.forEach(c => root.setProperty('--c-' + c, t[c]));
  // Update theme panel selection
  document.querySelectorAll('.theme-option').forEach(el => {
    el.classList.toggle('selected', el.dataset.theme === themeId);
  });
  // Re-render if game is running
  try { if (board && board.length) renderAll(); } catch(e) {}
}

function buildThemePanel() {
  const list = document.getElementById('theme-list');
  list.innerHTML = '<h3>ÏÉâÏÉÅ ÌÖåÎßà</h3>';
  for (const [id, theme] of Object.entries(THEMES)) {
    const opt = document.createElement('div');
    opt.className = 'theme-option' + (id === currentTheme ? ' selected' : '');
    opt.dataset.theme = id;
    const dots = ALL_COLORS.map(c => `<span style="background:${theme.hex[c]}"></span>`).join('');
    opt.innerHTML = `<span class="theme-name">${theme.name}</span><div class="theme-dots">${dots}</div>`;
    opt.onclick = () => { applyTheme(id); toggleThemePanel(); };
    list.appendChild(opt);
  }
}

function toggleThemePanel() {
  const panel = document.getElementById('theme-panel');
  panel.classList.toggle('active');
}

// Init theme on load
buildThemePanel();
applyTheme(currentTheme);
const BOARD_SIZE = 5;

// Tile types:
// 1: color fixed, free placement
// 2: color random, free placement
// 3: color fixed, row or col (EXISTING)
// 4: color random, row or col
// 5: color fixed, cross (row+col)
// 6: color random, cross (row+col)
const TILE_WEIGHTS = [
  { type: 3, weight: 90 },
  { type: 1, weight: 2 },
  { type: 2, weight: 2 },
  { type: 4, weight: 2 },
  { type: 5, weight: 2 },
  { type: 6, weight: 2 },
];
const TOTAL_WEIGHT = TILE_WEIGHTS.reduce((s, w) => s + w.weight, 0);

// Levels
const LEVELS = [
  { minScore: 0,    colors: 4, label: '' },
  { minScore: 500,  colors: 5, label: '+Ìåå Ìï¥Í∏à!' },
  { minScore: 1000, colors: 6, label: '+ÎÇ® Ìï¥Í∏à!' },
  { minScore: 1500, colors: 6, label: 'ÏûêÎèô ÏÉâÎ≥ÄÍ≤Ω!', autoChange: true },
  { minScore: 2000, colors: 7, label: '+Î≥¥ Ìï¥Í∏à!', autoChange: true },
  { minScore: 2500, colors: 7, label: 'Î¨¥Ìö®Î∏îÎ°ù Îì±Ïû•!', autoChange: true, voidBlocks: true },
];

// Mission shapes
const MISSION_SHAPES = [
  { id:'h3', cells:[[0,0],[0,1],[0,2]], bonus:30 },
  { id:'h4', cells:[[0,0],[0,1],[0,2],[0,3]], bonus:50 },
  { id:'h5', cells:[[0,0],[0,1],[0,2],[0,3],[0,4]], bonus:80 },
  { id:'v3', cells:[[0,0],[1,0],[2,0]], bonus:30 },
  { id:'v4', cells:[[0,0],[1,0],[2,0],[3,0]], bonus:50 },
  { id:'v5', cells:[[0,0],[1,0],[2,0],[3,0],[4,0]], bonus:80 },
  { id:'giyeok', cells:[[0,0],[0,1],[1,1]], bonus:40 },
  { id:'nieun', cells:[[0,0],[1,0],[1,1]], bonus:40 },
  { id:'L', cells:[[0,0],[1,0],[2,0],[2,1]], bonus:50 },
  { id:'T', cells:[[0,0],[0,1],[0,2],[1,1]], bonus:50 },
  { id:'sq', cells:[[0,0],[0,1],[1,0],[1,1]], bonus:60 },
  { id:'S', cells:[[0,0],[0,1],[1,1],[1,2]], bonus:50 },
  { id:'Z', cells:[[0,1],[0,2],[1,0],[1,1]], bonus:50 },
];

// ============================================================
// STATE
// ============================================================
let board = [];       // null | { color, isVoid }
let queue = [];       // { type, color(or null), dir(or null), num(or null) }
let score = 0;
let combo = 0;
let maxCombo = 0;
let colorChangeMode = false;
let gameActive = false;
let inputLocked = false;
let currentMission = null;
let turnCount = 0;
let missionTurnCounter = 0;
let voidTurnCounter = 0;
let prevLevel = null;
let voidSpawnedAt2500 = false;

// ============================================================
// UTILITY
// ============================================================
function rand(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

function getLevel() {
  let lv = LEVELS[0];
  for (const l of LEVELS) if (score >= l.minScore) lv = l;
  return lv;
}

function getActiveColors() {
  return ALL_COLORS.slice(0, getLevel().colors);
}

// ============================================================
// BOARD
// ============================================================
function initBoard() {
  board = [];
  for (let r = 0; r < BOARD_SIZE; r++) board.push(new Array(BOARD_SIZE).fill(null));
}

function cellOccupied(r, c) { return board[r][c] !== null; }
function cellPlayable(r, c) { return board[r][c] === null; }

function getAvailableLines() {
  const lines = [];
  for (let r = 0; r < BOARD_SIZE; r++) {
    let empty = 0;
    for (let c = 0; c < BOARD_SIZE; c++) if (!cellOccupied(r, c)) empty++;
    if (empty > 0) lines.push({ dir: 'row', num: r + 1 });
  }
  for (let c = 0; c < BOARD_SIZE; c++) {
    let empty = 0;
    for (let r = 0; r < BOARD_SIZE; r++) if (!cellOccupied(r, c)) empty++;
    if (empty > 0) lines.push({ dir: 'col', num: c + 1 });
  }
  return lines;
}

function hasAnyEmptyCell() {
  for (let r = 0; r < BOARD_SIZE; r++)
    for (let c = 0; c < BOARD_SIZE; c++)
      if (!board[r][c]) return true;
  return false;
}

function hasTilesOnBoard() {
  for (let r = 0; r < BOARD_SIZE; r++)
    for (let c = 0; c < BOARD_SIZE; c++)
      if (board[r][c] && !board[r][c].isVoid) return true;
  return false;
}

function isBoardEmpty() {
  for (let r = 0; r < BOARD_SIZE; r++)
    for (let c = 0; c < BOARD_SIZE; c++)
      if (board[r][c]) return false;
  return true;
}

// ============================================================
// TILE GENERATION
// ============================================================
function pickTileType() {
  let r = Math.random() * TOTAL_WEIGHT;
  for (const tw of TILE_WEIGHTS) {
    r -= tw.weight;
    if (r <= 0) return tw.type;
  }
  return 3;
}

function generateTile(useBoard) {
  const colors = getActiveColors();
  const type = pickTileType();
  const hasColor = (type === 1 || type === 3 || type === 5);
  const color = hasColor ? rand(colors) : null;

  // Types 1,2: free placement - no dir/num
  if (type === 1 || type === 2) {
    if (useBoard && !hasAnyEmptyCell()) return null;
    return { type, color, dir: null, num: null };
  }

  // Types 3,4: single line
  if (type === 3 || type === 4) {
    let dir, num;
    if (useBoard) {
      const lines = getAvailableLines();
      if (lines.length === 0) return null;
      const pick = rand(lines);
      dir = pick.dir; num = pick.num;
    } else {
      dir = rand(['row', 'col']);
      num = randInt(1, BOARD_SIZE);
    }
    return { type, color, dir, num };
  }

  // Types 5,6: cross (row+col with same num)
  if (type === 5 || type === 6) {
    if (useBoard) {
      // Need a num where either its row or col has empty cells
      const validNums = [];
      for (let n = 1; n <= BOARD_SIZE; n++) {
        const r = n - 1, c = n - 1;
        let hasEmpty = false;
        for (let i = 0; i < BOARD_SIZE; i++) {
          if (!cellOccupied(r, i) || !cellOccupied(i, c)) { hasEmpty = true; break; }
        }
        if (hasEmpty) validNums.push(n);
      }
      if (validNums.length === 0) return null;
      return { type, color, dir: 'cross', num: rand(validNums) };
    } else {
      return { type, color, dir: 'cross', num: randInt(1, BOARD_SIZE) };
    }
  }

  return { type: 3, color: rand(colors), dir: rand(['row','col']), num: randInt(1, BOARD_SIZE) };
}

function getValidCells(tile) {
  const cells = [];
  if (!tile) return cells;

  // Type 1,2: all empty cells
  if (tile.type === 1 || tile.type === 2) {
    for (let r = 0; r < BOARD_SIZE; r++)
      for (let c = 0; c < BOARD_SIZE; c++)
        if (cellPlayable(r, c)) cells.push({ r, c });
    return cells;
  }

  // Type 3,4: single line
  if (tile.type === 3 || tile.type === 4) {
    if (tile.dir === 'row') {
      const r = tile.num - 1;
      for (let c = 0; c < BOARD_SIZE; c++) if (cellPlayable(r, c)) cells.push({ r, c });
    } else {
      const c = tile.num - 1;
      for (let r = 0; r < BOARD_SIZE; r++) if (cellPlayable(r, c)) cells.push({ r, c });
    }
    return cells;
  }

  // Type 5,6: cross
  if (tile.type === 5 || tile.type === 6) {
    const n = tile.num - 1;
    const added = new Set();
    // Row n
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (cellPlayable(n, c) && !added.has(`${n},${c}`)) {
        cells.push({ r: n, c });
        added.add(`${n},${c}`);
      }
    }
    // Col n
    for (let r = 0; r < BOARD_SIZE; r++) {
      if (cellPlayable(r, n) && !added.has(`${r},${n}`)) {
        cells.push({ r, c: n });
        added.add(`${r},${n}`);
      }
    }
    return cells;
  }

  return cells;
}

// ============================================================
// VOID BLOCKS
// ============================================================
function spawnVoidBlock() {
  const emptyCells = [];
  for (let r = 0; r < BOARD_SIZE; r++)
    for (let c = 0; c < BOARD_SIZE; c++)
      if (!board[r][c]) emptyCells.push({ r, c });
  if (emptyCells.length === 0) return;
  const pos = rand(emptyCells);
  board[pos.r][pos.c] = { color: rand(getActiveColors()), isVoid: true };
}

function crackAdjacentVoids(clearedCells) {
  const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
  const cracked = [];
  const clearedSet = new Set(clearedCells.map(c => `${c.r},${c.c}`));
  for (const { r, c } of clearedCells) {
    for (const [dr, dc] of dirs) {
      const nr = r + dr, nc = c + dc;
      if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) continue;
      const cell = board[nr][nc];
      if (cell && cell.isVoid && !clearedSet.has(`${nr},${nc}`)) {
        cracked.push({ r: nr, c: nc });
      }
    }
  }
  for (const { r, c } of cracked) {
    board[r][c] = { color: board[r][c].color, isVoid: false };
  }
  return cracked;
}

// ============================================================
// MATCH DETECTION
// ============================================================
function findMatches() {
  const visited = Array.from({ length: BOARD_SIZE }, () => new Array(BOARD_SIZE).fill(false));
  const groups = [];
  const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (visited[r][c] || !board[r][c] || board[r][c].isVoid) continue;
      const color = board[r][c].color;
      const group = [];
      const stack = [{ r, c }];
      visited[r][c] = true;
      while (stack.length) {
        const cur = stack.pop();
        group.push(cur);
        for (const [dr, dc] of dirs) {
          const nr = cur.r + dr, nc = cur.c + dc;
          if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE
              && !visited[nr][nc] && board[nr][nc] && !board[nr][nc].isVoid
              && board[nr][nc].color === color) {
            visited[nr][nc] = true;
            stack.push({ r: nr, c: nc });
          }
        }
      }
      if (group.length >= 3) groups.push({ color, cells: group });
    }
  }
  return groups;
}

function collectCells(matches) {
  const set = new Set();
  for (const g of matches) for (const c of g.cells) set.add(`${c.r},${c.c}`);
  return set;
}

// ============================================================
// MISSION
// ============================================================
function generateMission() {
  currentMission = { ...rand(MISSION_SHAPES) };
  renderMission();
}

function renderMission() {
  const grid = document.getElementById('mission-grid');
  const bonus = document.getElementById('mission-bonus');
  grid.innerHTML = '';
  if (!currentMission) { bonus.textContent = ''; return; }
  const cells = currentMission.cells;
  const maxR = Math.max(...cells.map(c => c[0])) + 1;
  const maxC = Math.max(...cells.map(c => c[1])) + 1;
  grid.style.gridTemplateColumns = `repeat(${maxC}, 12px)`;
  grid.style.gridTemplateRows = `repeat(${maxR}, 12px)`;
  const cellSet = new Set(cells.map(c => `${c[0]},${c[1]}`));
  for (let r = 0; r < maxR; r++) {
    for (let c = 0; c < maxC; c++) {
      const dot = document.createElement('div');
      dot.className = cellSet.has(`${r},${c}`) ? 'mission-dot' : 'mission-dot empty';
      grid.appendChild(dot);
    }
  }
  bonus.textContent = `+${currentMission.bonus}`;
}

function getRotations(cells) {
  const results = [];
  let cur = cells.map(c => [...c]);
  for (let i = 0; i < 4; i++) {
    const minR = Math.min(...cur.map(c => c[0]));
    const minC = Math.min(...cur.map(c => c[1]));
    results.push(cur.map(c => [c[0] - minR, c[1] - minC]));
    cur = cur.map(([r, c]) => [c, -r]);
  }
  return results;
}

function checkMissionComplete(clearedCells) {
  if (!currentMission) return false;
  const rotations = getRotations(currentMission.cells);
  const clearedSet = new Set(clearedCells.map(c => `${c.r},${c.c}`));
  for (const shape of rotations) {
    for (const anchor of clearedCells) {
      const dr = anchor.r - shape[0][0];
      const dc = anchor.c - shape[0][1];
      const translated = shape.map(([r, c]) => [r + dr, c + dc]);
      if (translated.every(([r, c]) => clearedSet.has(`${r},${c}`))) return true;
    }
  }
  return false;
}

// ============================================================
// RENDERING
// ============================================================
function renderBoard() {
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';
  const currentTile = queue[0];
  const validCells = (currentTile && !colorChangeMode && !inputLocked) ? getValidCells(currentTile) : [];

  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      const data = board[r][c];
      if (data) {
        const tile = document.createElement('div');
        tile.className = `tile color-${data.color}`;
        if (data.isVoid) tile.classList.add('void-tile');
        cell.appendChild(tile);
        if (colorChangeMode && !data.isVoid) cell.classList.add('change-target');
      }
      if (validCells.some(v => v.r === r && v.c === c)) cell.classList.add('highlight');
      cell.addEventListener('click', () => onCellClick(r, c));
      boardEl.appendChild(cell);
    }
  }
}

function renderQueue() {
  const ids = ['current', 'next', 'nextnext'];
  for (let i = 0; i < 3; i++) {
    const t = queue[i];
    const preview = document.getElementById(`qp-${ids[i]}`);
    preview.innerHTML = '';
    if (!t) { preview.className = 'tile-preview'; continue; }

    const hasColor = (t.color !== null);
    preview.className = `tile-preview ${hasColor ? 'color-' + t.color : 'color-unknown'}`;

    // Lines based on type
    if (t.type === 3 || t.type === 4) {
      const line = document.createElement('div');
      line.className = `tile-line ${t.dir === 'row' ? 'horizontal' : 'vertical'}`;
      preview.appendChild(line);
    }
    // Number (only for types with position)
    if (t.num !== null) {
      const num = document.createElement('div');
      num.className = 'tile-num';
      num.textContent = t.num;
      // Cross tiles (5,6) have no line background, so use white for contrast
      num.style.color = (t.type === 5 || t.type === 6) ? '#fff' : (hasColor ? COLOR_HEX[t.color] : '#333');
      preview.appendChild(num);
    }
  }
}

function renderLabels() {
  const rowL = document.getElementById('row-labels');
  const colL = document.getElementById('col-labels');
  rowL.innerHTML = ''; colL.innerHTML = '';
  for (let i = 1; i <= BOARD_SIZE; i++) {
    let d = document.createElement('div'); d.className = 'lbl'; d.textContent = i; rowL.appendChild(d);
    d = document.createElement('div'); d.className = 'lbl'; d.textContent = i; colL.appendChild(d);
  }
}

function setStatus(text) {
  const el = document.getElementById('status');
  if (text) { el.textContent = text; el.classList.remove('hidden'); }
  else { el.classList.add('hidden'); }
}

function updateComboDisplay() {
  const el = document.getElementById('combo-display');
  document.getElementById('combo').textContent = combo;
  if (combo >= 2) el.classList.remove('hidden');
  else el.classList.add('hidden');
}

function updateLevelDisplay() {
  const lv = getLevel();
  const colors = getActiveColors();
  const names = colors.map(c => COLOR_KR[c]).join(' ');
  let extra = '';
  if (lv.autoChange) extra += ' | ÏûêÎèôÎ≥ÄÍ≤Ω';
  if (lv.voidBlocks) extra += ' | Î¨¥Ìö®Î∏îÎ°ù';
  document.getElementById('level-display').textContent = `[ ${names}${extra} ]`;
}

function renderAll() {
  renderBoard();
  renderQueue();
  document.getElementById('score').textContent = score;
  updateComboDisplay();
  updateLevelDisplay();
}

function showPopup(text, cls) {
  const el = document.createElement('div');
  el.className = cls;
  el.textContent = text;
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 2000);
}

// ============================================================
// LEVEL TRANSITION
// ============================================================
function checkLevelUp() {
  const newLevel = getLevel();
  if (prevLevel && newLevel.minScore > prevLevel.minScore) {
    if (newLevel.label) showPopup(newLevel.label, 'level-popup');
    if (newLevel.voidBlocks && !voidSpawnedAt2500) {
      voidSpawnedAt2500 = true;
      voidTurnCounter = 0;
      spawnVoidBlock();
    }
  }
  prevLevel = newLevel;
}

// ============================================================
// GAME LOGIC
// ============================================================
function onCellClick(r, c) {
  if (!gameActive || inputLocked) return;

  // --- COLOR CHANGE ---
  if (colorChangeMode) {
    if (!hasTilesOnBoard()) {
      if (!board[r][c]) {
        board[r][c] = { color: rand(getActiveColors()), isVoid: false };
        endColorChange(r, c);
      }
      return;
    }
    if (board[r][c] && !board[r][c].isVoid) {
      const oldColor = board[r][c].color;
      const others = getActiveColors().filter(cl => cl !== oldColor);
      board[r][c] = { color: rand(others), isVoid: false };
      endColorChange(r, c);
    }
    return;
  }

  // --- PLACE TILE ---
  const tile = queue[0];
  if (!tile) return;
  const valid = getValidCells(tile);
  if (!valid.some(v => v.r === r && v.c === c)) return;

  // Determine color: if colorless, random
  const placedColor = tile.color || rand(getActiveColors());
  board[r][c] = { color: placedColor, isVoid: false };
  turnCount++;
  missionTurnCounter++;

  // Void block spawning
  const lv = getLevel();
  if (lv.voidBlocks) {
    voidTurnCounter++;
    if (voidTurnCounter >= 5) {
      voidTurnCounter = 0;
      spawnVoidBlock();
    }
  }

  renderBoard();
  const idx = r * BOARD_SIZE + c;
  const tileEl = document.getElementById('board').children[idx].querySelector('.tile');
  if (tileEl) tileEl.classList.add('place');

  advanceQueue();
  renderQueue();

  inputLocked = true;
  setTimeout(() => { inputLocked = false; resolveAfterPlace(); }, 300);
}

function endColorChange(r, c) {
  colorChangeMode = false;
  setStatus(null);
  renderAll();
  const idx = r * BOARD_SIZE + c;
  const tileEl = document.getElementById('board').children[idx].querySelector('.tile');
  if (tileEl) tileEl.classList.add('color-swap');

  inputLocked = true;
  setTimeout(() => {
    inputLocked = false;
    const lv = getLevel();
    if (lv.autoChange) {
      doAutoColorChange(() => resolveAfterColorChange());
    } else {
      resolveAfterColorChange();
    }
  }, 600);
}

function doAutoColorChange(callback) {
  const candidates = [];
  for (let r = 0; r < BOARD_SIZE; r++)
    for (let c = 0; c < BOARD_SIZE; c++)
      if (board[r][c] && !board[r][c].isVoid) candidates.push({ r, c });
  if (candidates.length === 0) { callback(); return; }

  const pick = rand(candidates);
  const oldColor = board[pick.r][pick.c].color;
  const others = getActiveColors().filter(cl => cl !== oldColor);
  board[pick.r][pick.c] = { color: rand(others), isVoid: false };

  setStatus('ÏûêÎèô ÏÉâÏÉÅ Î≥ÄÍ≤Ω!');
  renderAll();
  const idx = pick.r * BOARD_SIZE + pick.c;
  const tileEl = document.getElementById('board').children[idx].querySelector('.tile');
  if (tileEl) tileEl.classList.add('color-swap');

  inputLocked = true;
  setTimeout(() => {
    inputLocked = false;
    setStatus(null);
    callback();
  }, 600);
}

function advanceQueue() {
  queue.shift();
  const newTile = generateTile(true);
  if (newTile) queue.push(newTile);
  while (queue.length < 3) {
    const t = generateTile(true);
    if (t) queue.push(t);
    else break;
  }
}

// ============================================================
// SCORE: combo multiplier
// ============================================================
function calcScore(cleared, comboNum, missionDone) {
  // Base: cleared * 10 * comboMultiplier
  let s = cleared * 10 * Math.max(comboNum, 1);
  if (missionDone && currentMission) s += currentMission.bonus;
  return s;
}

// ============================================================
// RESOLVE PHASES
// ============================================================
function resolveAfterPlace() {
  const matches = findMatches();
  if (matches.length > 0) {
    combo++;
    if (combo > maxCombo) maxCombo = combo;
    if (combo >= 2) showPopup(`${combo} COMBO! x${combo}`, 'combo-popup');

    const cellsToRemove = collectCells(matches);
    const clearedList = setToList(cellsToRemove);
    let missionDone = checkMissionComplete(clearedList);
    score += calcScore(cellsToRemove.size, combo, missionDone);
    if (missionDone) { showPopup(`MISSION! +${currentMission.bonus}`, 'mission-popup'); generateMission(); }
    checkLevelUp();

    animateRemoval(cellsToRemove, clearedList, () => {
      enterColorChangeMode();
    });
  } else {
    combo = 0;
    updateComboDisplay();
    maybeNewMission();
    renderAll();
    checkGameOver();
  }
}

function resolveAfterColorChange() {
  const matches = findMatches();
  if (matches.length > 0) {
    combo++;
    if (combo > maxCombo) maxCombo = combo;
    if (combo >= 2) showPopup(`${combo} COMBO! x${combo}`, 'combo-popup');

    const cellsToRemove = collectCells(matches);
    const clearedList = setToList(cellsToRemove);
    let missionDone = checkMissionComplete(clearedList);
    score += calcScore(cellsToRemove.size, combo, missionDone);
    if (missionDone) { showPopup(`MISSION! +${currentMission.bonus}`, 'mission-popup'); generateMission(); }
    checkLevelUp();

    animateRemoval(cellsToRemove, clearedList, () => resolveChain());
  } else {
    maybeNewMission();
    renderAll();
    checkGameOver();
  }
}

function resolveChain() {
  const matches = findMatches();
  if (matches.length > 0) {
    combo++;
    if (combo > maxCombo) maxCombo = combo;
    if (combo >= 2) showPopup(`${combo} COMBO! x${combo}`, 'combo-popup');

    const cellsToRemove = collectCells(matches);
    const clearedList = setToList(cellsToRemove);
    let missionDone = checkMissionComplete(clearedList);
    score += calcScore(cellsToRemove.size, combo, missionDone);
    if (missionDone) { showPopup(`MISSION! +${currentMission.bonus}`, 'mission-popup'); generateMission(); }
    checkLevelUp();

    animateRemoval(cellsToRemove, clearedList, () => resolveChain());
  } else {
    maybeNewMission();
    renderAll();
    checkGameOver();
  }
}

function setToList(set) {
  return [...set].map(k => { const [r, c] = k.split(',').map(Number); return { r, c }; });
}

function animateRemoval(cellsToRemove, clearedList, callback) {
  renderAll();
  const boardEl = document.getElementById('board');
  for (const key of cellsToRemove) {
    const [rr, cc] = key.split(',').map(Number);
    const idx = rr * BOARD_SIZE + cc;
    const tileEl = boardEl.children[idx].querySelector('.tile');
    if (tileEl) tileEl.classList.add('pop');
  }

  inputLocked = true;
  setTimeout(() => {
    const cracked = crackAdjacentVoids(clearedList);

    for (const key of cellsToRemove) {
      const [rr, cc] = key.split(',').map(Number);
      board[rr][cc] = null;
    }

    if (isBoardEmpty()) {
      score += 100;
      showPopup('CLEAR! +100', 'mission-popup');
    }

    if (cracked.length > 0) {
      renderAll();
      const boardEl2 = document.getElementById('board');
      for (const { r, c } of cracked) {
        const idx = r * BOARD_SIZE + c;
        const tileEl = boardEl2.children[idx].querySelector('.tile');
        if (tileEl) tileEl.classList.add('color-swap');
      }
      setTimeout(() => { inputLocked = false; callback(); }, 400);
    } else {
      inputLocked = false;
      callback();
    }
  }, 450);
}

function enterColorChangeMode() {
  colorChangeMode = true;
  if (hasTilesOnBoard()) {
    setStatus('ÏÉâÏÉÅ Î≥ÄÍ≤Ω! ÌÉÄÏùºÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî');
  } else {
    setStatus('Îπà Ïπ∏ÏùÑ ÌÅ¥Î¶≠ÌïòÎ©¥ ÎûúÎç§ ÌÉÄÏùº ÏÉùÏÑ±');
  }
  renderBoard();
}

function maybeNewMission() {
  if (missionTurnCounter >= 3) {
    missionTurnCounter = 0;
    generateMission();
  }
}

function checkGameOver() {
  if (!queue[0]) { gameOver(); return; }
  if (getValidCells(queue[0]).length === 0) { gameOver(); return; }
}

function gameOver() {
  gameActive = false;
  document.getElementById('final-score').textContent = score;
  document.getElementById('final-combo').textContent = maxCombo >= 2 ? `ÏµúÎåÄ ÏΩ§Î≥¥: ${maxCombo}` : '';
  const lv = getLevel();
  const cNames = ALL_COLORS.slice(0, lv.colors).map(c => COLOR_KR[c]).join('');
  document.getElementById('final-level').textContent = `ÎèÑÎã¨ ÏÉâÏÉÅ: ${cNames}`;
  document.getElementById('game-over').classList.add('active');
}

// ============================================================
// INIT
// ============================================================
function initGame() {
  initBoard();
  score = 0;
  combo = 0;
  maxCombo = 0;
  colorChangeMode = false;
  inputLocked = false;
  gameActive = true;
  turnCount = 0;
  missionTurnCounter = 0;
  voidTurnCounter = 0;
  prevLevel = LEVELS[0];
  voidSpawnedAt2500 = false;
  currentMission = null;

  document.getElementById('game-over').classList.remove('active');
  setStatus(null);

  queue = [];
  for (let i = 0; i < 3; i++) queue.push(generateTile(false));

  generateMission();
  renderLabels();
  renderAll();
}

initGame();
</script>
</body>
</html>
